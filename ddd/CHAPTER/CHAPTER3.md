###애그리거트

####애그리거트
* 상위 수준의 개념을 이용해서 전체 모델을 정리하면 전반적인 관계를 이해하는 데 도움이 된다.
* 애그리거트는 모델을 이해하는데 도움을 줄 뿐만 아니라 일관성을 관리하는 기준이 되며, 복잡한 도메인을 단순한 구조로 만들어주어 도메인 기능을 확장하고 변경하는데 필요한 노력(개발 시간)이 줄어든다.

####애그리거트 루트
* 애그리거트에 속한 모든 객체가 일관된 상태를 유지하려면 애그리거트 전체를 관리할 주체가 필요한데 이 책임을 지는 것이 바로 애그리거트의 루트 엔티티이다.
* 애그리거트에 속한 객체는 애그리거트 루트 엔티티에 직접 또는 간접적으로 속한다.
 
####도메인 규칙과 일관성
* 애그리거트 루트를 통해서만 도메인 로직을 구현하게 만들려면 도메인 모델에 대해 다음의 두 가지를 습관적으로 적용해야 한다.
    * 단순히 필드를 변경하는 set 메서드를 공개(public) 범위로 만들지 않는다.
        * 공개 set 메서드는 중요 도메인의 의미나 의도를 표현하지 못하고 도메인 로직이 도메인 객체가 아닌 응용 영역이나 표현 영역으로 분산되게 만드는 원인이 된다.
        * 공개 set 메서드를 사용하지 않으면 의미가 드러나는 cancel, changePassword 처럼 의미가 더 잘 드러나는 이름을 사용하는 빈도가 높아진다.
        
    * 밸류 타입은 불변으로 구현한다.
        * 밸류 객체가 불변이면 애그리거트 루트가 제공하는 메서드에 새로운 밸류 객체를 전달해서 값을 변경하는 방법 밖에 없다. 이로서 애그리거트 루트가 도메인 규칙을 올바르게만 구현하면 애그리거트 전체의 일관성을 올바르게 유지할 수 있다.

####ID를 이용한 애그리거트 참조
* ORM 기술으로 애그리거트 루트에 대한 참조를 쉽게 구현할 수 있다. 하지만 필드를 이용한 애그리거트 참조는 문제점을 야기할 수 있다.
    * 편한 탐색 오용
        * 다른 애그리거트 객체에 접근할 수 있으면 한 애그리거트에서 다른 애그리거트의 상태를 변경하는 유혹에 빠지기 쉽다.

    * 성능에 대한 고민
        * 애그리거트를 직접 참조하면 성능과 관련된 여러가지 고민을 해야한다.
        * JPA 의 lazy/eager loading 을 조회/변경에 따라 다양한 수를 고려해야한다.
        * 연관 맵핑과 JPQL/Criteria 쿼리의 로딩 전략을 결정해야 한다.
        
    * 확장 어려움
        * 서비스가 커지면서 도메인 별 다른 DB를 사용할 시 JPA 같은 단일 기술을 사용할 수 없다.
        * 하위 도메인 마다 다른 종류의 데이터  저장소를 사용하기도 한다.
        * ex) 한 하위 도메인은 마리아 DB, 다른 하위 도메인은  몽고 DB
        
* 이런 세 가지 문제를 완화할 때 사용할 수 있는 것이 ID를 이용해서 다른 애그리거트를 참조하는 것이다.

####ID를 이용한 참조와 조회 성능
* 처음 JPA 를 사용하면 각 객체 간 모든 연관을 지연 로딩과 즉시 로딩으로 어떻게든 처리하고 싶은 욕구에 사로잡히는데, 때에 따라서는, ID를 이용해 애그리거트를 참조하는 실용적인 방법도 고민하자.