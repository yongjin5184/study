1. **페이스북 메신저란?**
    - 페이스북 메신저는 텍스트 기반의 인스턴스 메시징 서비스를 제공하는 소프트웨어 어플리케이션

2.  **요구사항 및 시스템의 목표**

- 기능 요구 사항
    1. 일대일 대화가 가능
    2. 온/오프라인 상태를 추적
    3. 채팅 히스토리의 영속적인 저장

- 비 기능 요구 사항
    1. 최소 대기 시간의 채팅 경험
    2. 높은 일관성
    3. 높은 가용성, 일관성 > 가용성

- 확장된 요구 사항
    1. 그룹채팅
    2. offline 상태일때, 푸시알림

**3. 용량 추정 및 제약사항**

- (활성 유저) 500 million * (평균 사용자 발송량) 40 messages = 20 billion messages per day.
- 20 billion * (평균 사용자 문자 크기) 100 bytes = 2TB
- 대략 5년 보관

    2TB * 365 days * 5 years = 3.6 PB

- 대역폭

    2TB / 24H * 60M * 60S = 25MB/s

**4. 고수준 디자인**

- 사용자 사이의 커뮤니케이션을 관장하는 **중앙 채팅 서버**
- 채팅을 저장하는 **스토리지**
- workflow

    [](https://www.notion.so/3db8791766414841b7185e9d4139747a#38b1a66c98774980a87fbdf5bbd540d3)

**5. 세부적인 구성 요소 디자인**

1) 메시지 처리

사용자는 서버에 연결해야하고 다른 사용자에게 메시지를 게시(Post) 해야 한다.

서버로 부터 메시지를 받기 위해서 사용자는 2가지 옵션을 가질 수 있다.

- Pull model

    사용자가 주기적으로 서버에 묻는 방식

    사용자 대기시간을 최소화 하기위해 서버를 자주 확인하고, 대부분 빈 응답을 반환. 비효율적

- Push model
    - 사용자는 서버와의 연결을 유지하고, 서버가 새로운 메시지가 있으면 사용자에게 알려준다.
    - 보류중(Pending)인 메시지를 추적하지 않아도 된다.
    - 대기시간 최소화
    - long polling

        새 데이터가 없는 경우, 빈 응답 대신 서버는 연결을 유지하고 응답 정보를 사용할 수 있을 때까지 기다린다 → 표현 맞는지(?).

        대기시간, 처리량 성능 향상

    - websocket

Q. 어떻게 서버가 모든 열려있는 커넥션을 추적하여 메시지를 효율적으로 사용자에게 리다이렉션 할 수 있을까?

- 해쉬 테이블을 이용, key - UserID / value - connection object
- 서버가 메시지를 받을때 마다, 해쉬테이블에서 UserID로 connection object를 찾아서 메시지를 보낸다.

Q.  메시지를 받는 사람이 offline일 경우, 서버는 어떻게 할 것인가?

- 일시적인 disconnect 인 경우, 유저가 reconnect 하도록 해야한다.
- 서버는 메시지를 저장할 수 있다 잠시동안 그리고 수신자가 재 접속하면 다시 retry 할 수 있다.

Q. 메시지 순서는 어떻게 유지할 것인가?

- 각 메시지의 타임스템프를 저장한다.
- 그럼에도 불구하고 분산 서버 환경이기 때문에 정확한 순서를 보장할 수 는 없다.
- 이는 각 메시지 마다 sequence number를 유지시켜야 한다. 이 순서로 정확한 메시지 순서를 결정.

2) 데이터베이스에 메시지 저장 및 검색

1. 별도의 thread를 통해 메시지를 저장한다.
2. 비동기 요청으로 메시지를 저장한다.

Q. DB 선택은 어떻게 하는가??

- insert 해야하는 많은 수의 작은 message, 조회시는 순차적으로 access 될 가능성이 많다.
- HBase 는  column  지향 key-value  Nosql database
- 메모리 버퍼에 우선 저장 후, 버퍼가 가득 차면 데이터를 디스크에 덤프한다.

3. 사용자 상태 관리

- 모든 활성 사용자에게 브로드캐스트 하기에는 많은 리소스가 사용됨.

6. 데이터 파티셔닝

- UserID 기반의 파티셔닝

    처음에는 하나의 물리적 서버에 논리적 샤드 구성을 통해 데이터 베이스를 운영한다. 논리적 파티셔닝을 분산하기 위해, 더 많은 물리적 서버를 추가 할 수도 있다.